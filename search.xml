<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web学习笔记</title>
      <link href="/2019/07/17/webLearning/"/>
      <url>/2019/07/17/webLearning/</url>
      
        <content type="html"><![CDATA[<p>尚在施工中，只完成了web server部分 : )</p><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><h3 id="Web-Server-基本原理"><a href="#Web-Server-基本原理" class="headerlink" title="Web Server 基本原理"></a>Web Server 基本原理</h3><p>当我们在浏览器浏览网页的时候，浏览器会先请求DNS Server，获得请求站点的IP Address，然后发送一个HTTP Request给该IP Address对应的主机，接着就会收到该地址回传的HTTP Response，而浏览器经过渲染后，将网页以一定形式呈现给我们。在此过程之中等待请求作出响应的主机，就是我们所说的Web Server。</p><p>更详细地看，Web Server是一台物理服务器上的一台网络服务器（也可以理解为一个程序），它二十四小时永久等待Client（浏览器或者任何使用HTTP协议的软件）发送请求，并在接受请求之后，生成相应的响应回传给Client。Web Server 和 Client之间使用的协议是HTTP，因此我们也将其称为HTTP Server。</p><p>Web Server能向Client提供文档，也可以放置网站文件、数据文件，供客户端浏览与下载。目前在UNIX和LINUX平台下最主流的Web Server是Apache和Nginx。</p><p><img src="/images/web.png" alt="Web Server"></p><p>Web Server的工作原理可以分为四个步骤：<strong>建立连接、请求过程、应答过程以及关闭连接</strong>。</p><ol><li>建立连接：Client通过TCP/IP协议建立到Server的TCP连接</li><li>请求过程：Client向Server发送HTTP协议请求包，请求服务器里的资源文档</li><li>应答过程：Server向Client发送HTTP协议的应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理动态内容，并将处理后的数据返回给客户端。客户端将揭示其HTML文档。</li><li>关闭连接：Client同Server断开连接。</li></ol><p>虽然Web Server的主要工作是request和response，但实际中的web server会有更多的服务，比如：</p><ul><li>缓存机制：将常访问页面缓存起来，提高响应速度</li><li>安全：防止黑客的各种攻击</li><li>并发处理：如何响应不同客户端同时发起的请求</li><li>日志：记录访问日志，方便做分析</li></ul><h3 id="Web-Server-简单实现"><a href="#Web-Server-简单实现" class="headerlink" title="Web Server 简单实现"></a>Web Server 简单实现</h3><p>我们可以一起来搭建一个简单的Web Server。</p><pre class=" language-c"><code class="language-c">unsighed <span class="token keyword">short</span> serverPort <span class="token operator">=</span> <span class="token number">8888</span><span class="token punctuation">;</span><span class="token keyword">int</span> serverSocket<span class="token punctuation">;</span><span class="token keyword">int</span> clientSocket<span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_in serverAddress<span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_in clientAddress<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>serverSocket <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> IPROTO_TCP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">die</span><span class="token punctuation">(</span><span class="token string">"socket failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// construct local address </span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serverAddress<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddress<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>serverAddress<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>serverAddress<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>serverAddress<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>serverSocket<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>serverAddress<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddress<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">die</span><span class="token punctuation">(</span><span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>serverSocket<span class="token punctuation">,</span> MAXPENDING<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">die</span><span class="token punctuation">(</span><span class="token string">"listen failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> clientLength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clientAddress<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>clientSocket <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>serverSocket<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>clientAddress<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientLength<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">die</span><span class="token punctuation">(</span><span class="token string">"accept failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">recv</span><span class="token punctuation">(</span>clientSocket<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">die</span><span class="token punctuation">(</span><span class="token string">"recv failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//analyze receive request</span><span class="token comment" spellcheck="true">//create response</span><span class="token keyword">char</span> response<span class="token punctuation">[</span>some length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"HTTP/1.1 200 OK\n"</span><span class="token punctuation">,</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">}</span>size_t n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">send</span><span class="token punctuation">(</span>clientSocket<span class="token punctuation">,</span> response<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">die</span><span class="token punctuation">(</span><span class="token string">"chunk send fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>clientSocket<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在terminal运行server后，我们可以通过<a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a> 来访问页面（会显示一行“hello world”）。</p><h3 id="Socket-amp-HTTP"><a href="#Socket-amp-HTTP" class="headerlink" title="Socket &amp; HTTP"></a>Socket &amp; HTTP</h3><p>让我们再多来谈谈URL，下图是它的基本结构，它告诉了客户端需要连接的web server和以及到达后需要访问的服务的页面（路径）。</p><p><img src="/images/Web_address.png" alt="url基本结构"></p><p>在客户端发送HTTP请求之前，它会与服务器建立一条TCP连接，然后通过该TCP连接发送一个HTTP Request并且收到HTTP Response。而建立TCP连接会使用Sockets，下图用了telnet指令来手动模拟该过程。</p><p><img src="/images/socket.png" alt="Socket"></p><p>建立TCP Connection后，客户端将发送HTTP Request，下图是请求的基本结构。</p><p><img src="/images/request.png" alt="HTTP request"></p><p>HTTP请求包含一个Action（GET），Path（/hello）以及HTTP Version（HTTP/1.1）。</p><p>而服务器返回的HTTP Response的基本结构如下：</p><p><img src="/images/response.png" alt="HTTP response"></p><p>HTTP响应将包含一行Header，其包括了Version 与 Status Code，接下来空一行，然后是HTTP Response Body。</p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Domain Name System(Authorized Reproduction)</title>
      <link href="/2019/07/17/dns/"/>
      <url>/2019/07/17/dns/</url>
      
        <content type="html"><![CDATA[<p>对于 <a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">DNS(Domain Name System)</a> 大家肯定不陌生，不就是用来将一个网站的域名转换为对应的IP吗。当我们发现可以上QQ但不能浏览网页时，我们会想到可能是域名服务器挂掉了；当我们用别人提供的hosts文件浏览到一个“<code>不存在</code>”的网页时，我们会了解到域名解析系统的脆弱。</p><p>然而关于DNS还有一大堆故事值得我们去倾听，去思考。</p><h2 id="DNS-源起"><a href="#DNS-源起" class="headerlink" title="DNS 源起"></a>DNS 源起</h2><p>要想访问网络上的一台计算机，我们必须要知道它的IP地址，但是这些地址（比如243.185.187.39）只是一串数字，没有规律，因此我们很难记住。并且如果一台计算机变更IP后，它必须通知所有的人。</p><p>显然，直接使用IP地址是一个愚蠢的方案。于是人们想出了一个替代的方法，即为每一台计算机起一个名字，然后建立计算机名字到地址的一个映射关系。我们访问计算机的名字，剩下的名字到地址的转换过程则由计算机自动完成。</p><h3 id="hosts映射"><a href="#hosts映射" class="headerlink" title="hosts映射"></a>hosts映射</h3><p>早期，名字到地址的转换过程十分简单。每台计算机保存一个<code>hosts</code>文件，里面列出所有计算机名字和对应的IP地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接。</p><p><img src="/images/hosts.png" alt="hosts管理主机"></p><p>早期的<a href="https://en.wikipedia.org/wiki/ARPANET" target="_blank" rel="noopener">ARPANET</a>就是这样做的，但是随着网络规模的扩大，这种方法渐渐吃不消了。主要有以下三个原因：</p><ol><li>hosts文件变得非常大；</li><li>主机名字会冲突；</li><li>集中的维护站点会不堪重负（需要给几百万机器提供hosts文件，想想就可怕）。</li></ol><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p>为了解决上面的问题，1983年<a href="https://en.wikipedia.org/wiki/Paul_Mockapetris" target="_blank" rel="noopener">Paul Mockapetris</a>提出了域名系统（DNS, Domain Name System)，这是一种<strong>层次的、基于域</strong>的命名方案，并且用一个分布式数据库系统加以实现。当我们需要访问一个域名（其实就是前面说的计算机的名字）时，应用程序会向DNS服务器发起一个DNS请求，DNS服务器返回该域名对应的IP地址。通过下面三种手段解决了上面的问题：</p><ol><li>用户计算机上并没有存储所有的名字到IP的映射，这样避免了hosts文件过于庞大（现在各操作系统中hosts文件默认都是空的）。</li><li>规定了域名的命名规则，保证主机名字不会重复。</li><li>DNS服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群。</li></ol><p>这样访问一个域名的过程可以简化为下图：</p><p><img src="/images/dns_concept.png" alt="域名hosts解析过程"></p><h2 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h2><p>那么如何具体实现这个所谓的域名系统呢，要知道管理一个超大型并且不断变化的域名到IP的映射集合可不是一个简单的事，况且还要去应付成千上万的DNS查询请求。人们最终想出了一套不错的协议，规定如何来实现这个系统，下面我们一起来看看吧。</p><h3 id="域名空间"><a href="#域名空间" class="headerlink" title="域名空间"></a>域名空间</h3><p>首先我们需要制定一套命名规则，防止域名出现重复。DNS关于域名的规则和我们生活中的快递系统类似，使用层次的地址结构。快递系统中要给某人邮寄物品，地址可能是这样：中国、广东省、广州市、番禺区、中山西路12号 XXX。而一个域名看起来则是这样的groups.google.com（为什么不是com.google.groups？我猜可能和老外写地址的习惯有关）。</p><p>对于Internet来说，域名层次结构的顶级（相当于国际快递地址中的国家部分）由<a href="https://www.icann.org/" target="_blank" rel="noopener">ICANN</a>（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推。所有这些域名可以组织成一棵树，如下图所示（图片来自Computer Networks: 7-1 ）</p><p><img src="/images/domain_tree.png" alt="域名空间树"></p><h3 id="域名资源记录"><a href="#域名资源记录" class="headerlink" title="域名资源记录"></a>域名资源记录</h3><p>DNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：</p><pre><code>Domain_name Time_to_live Class Type Value</code></pre><p>其中：</p><ol><li>Domain_name: 指出这条记录适用于哪个域名；</li><li><code>Time_to_live</code>: 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；</li><li>Class: 一般总是IN；</li><li>Type: 记录的类型；</li><li>Value: 记录的值，如果是A记录，则value是一个IPv4地址。</li></ol><p>我们看到域名资源记录有一个Type字段，用来表明记录的类型。这是为什么呢？因为对于一个域名来说，通常并非只记录其IP地址，还可能需要一些其他种类的记录，一些常见的记录类型如下：</p><table><thead><tr><th>记录类型</th><th>含义</th></tr></thead><tbody><tr><td>A</td><td>主机的IPv4地址</td></tr><tr><td>AAAA</td><td>主机的IPv6地址</td></tr><tr><td>NS</td><td>该域名所在域的权威域名服务器</td></tr><tr><td>MX</td><td>接受特定域名电子邮件的服务器域名</td></tr><tr><td>CNAME</td><td>当前域名的一个别名</td></tr></tbody></table><p>关于这些域名资源记录的实例我们将在下一篇文章（实践篇）看到。</p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p>我们知道不能只用一台域名服务器来响应所有的DNS查询，因为没有一台机器能够给全球的用户提供查询服务，计算能力、存储、带宽都不允许。只能合理组织一个域名服务器集群，使他们协同工作，共同提供域名解析服务。接下来首先要面对的一个问题是<strong>如何合理地将所有的域名资源记录存储到不同的域名服务器上。</strong></p><p>前面说过域名的名字空间可以组织为一棵树，这里我们可以进一步将其划分为不重叠的区域（<a href="https://en.wikipedia.org/wiki/DNS_zone" target="_blank" rel="noopener">DNS zone</a>），针对上图的域名空间，一种可能的域名划分如下图：</p><p><img src="/images/domain_zone.png" alt="域名划分"></p><p>然后将每个区域与多个域名服务器（其中一个是master，其他slave服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的<code>权威域名服务器(Authoritative Name Servers )</code>，它保存两类域名资源记录：</p><ol><li>该区域内所有域名的域名资源记录。</li><li>父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。</li></ol><p>这样，所有的域名资源记录都保存在多个域名服务器中，并且所有的域名服务器也组成了一个层次的索引结构，便于我们后面进行域名解析。下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的，如下图a：</p><p><img src="/images/name_servers.png" alt="域名服务器"></p><p>图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器，这些域名服务器里面保存了许多域名解析记录。对于上图的NDS区域E来说，它的权威域名服务器里面保存的记录如图中表格所示。</p><p>仔细观察上图你可能会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起。这将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。认识到这一点后，你可能会想出一个很自然的解决方案，就是在A中记录B域名服务器的地址，同时在B中记录A的，这样它们两个就联系起来了。但是考虑到我们有超过250个顶级域名，这样做并不是很恰当。</p><p>而我们使用的域名系统则采用了一种更加聪明的方法，那就是引入<a href="https://en.wikipedia.org/wiki/Root_name_server" target="_blank" rel="noopener">根域名服务器</a>，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。下图为全球根域名服务器的分布图，可以在<a href="http://www.root-servers.org/" target="_blank" rel="noopener">这里</a>找到。</p><p>现在为止，我们的权威域名服务器和根域名服务器其实组成了一个树，树根为根域名服务器，下面每个节点都是一个区域的权威域名服务器，对于图a中各个DNS区域的权威域名服务器，它们组成了下面这棵树（<strong>实际中，一个权威域名服务器可能保存有多个DNS区域的记录，因此权威域名服务器之间的联系并不构成一棵树。这部分的详细内容可以参考RFC 1034: 4. NAME SERVERS。下面为了容易理解，将其简化为一棵树</strong>)：</p><p><img src="/images/servers_tree.png" alt="域名服务树"></p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>我们已经有了一个域名服务器集群，该集群合理地保存了域名空间和域名资源记录的对应关系。现在我们要做的就是发送一个DNS请求给域名服务器，然后坐等它返回正确的域名资源记录，这个过程叫作域名解析。</p><p>严格来说，域名解析的过程最早要追溯到建立网络连接。因为每当连接上网络之后，计算机会自动获得一个默认的DNS服务器，当然你也可以用自己信任的DNS服务器，比如8.8.8.8（DNS服务器也有信任不信任之分，是的，实践篇会讲到），我们把这个域名服务器也叫作<code>本地域名服务器</code>。接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。</p><p>如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是<strong>本地域名服务器如何找到根域名服务器在哪里呢？</strong>其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录（要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找啦。</p><p>仍然以我们的图a为例，现在假设区域E内的某个用户想访问math.sysu.edu.cn，那么请求的过程如下：</p><p><img src="/images/name_resolution.png" alt="域名解析过程"></p><p>用语言简单描述如下：</p><ol><li>用户：喂，本地域名服务器，告诉我math.sysu.edu.cn的地址；</li><li>本地域名服务器：哎呀，我不知道啊，不在我的辖区，容我去问问老大哥吧。root老大，能告诉我math.sysu.edu.cn的地址吗；</li><li>根域名服务器：忙着呢，你去问B（.cn）；</li><li>本地域名服务器：喂，B，告诉我math.sysu.edu.cn的地址；</li><li>B：你去问D（.edu.cn）；</li><li>本地域名服务器：喂，D，告诉我math.sysu.edu.cn的地址；</li><li>D：你去问F（sysu.edu.cn）；</li><li>本地域名服务器：喂，F，告诉我math.sysu.edu.cn的地址；</li><li>F：容老衲看看，哎呀，找到了，是X.X.X.X；</li><li>本地域名服务器：踏破铁鞋终于找到啦，喂用户，出来啊，我找到了，是X.X.X.X</li></ol><p>仔细想想，这和我们邮寄快递实在是如出一辙啊，假设你从美国邮东西到广州市番禺区，首先快递送到中国（不过这里没有一个类似根域名服务器的中转站而已），然后往下到广东省，接下来是广州市，再往下是番禺了。</p><p>上面的是本地域名服务器的迭代解析过程，其实也可以递归查询，这里就不说了，道理差不多。</p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>现在整个域名系统已经可以为我们提供域名解析服务了，当我们输入域名，计算机发送DNS请求，然后DNS服务器返回给我们解析的结果，一切看起来很完美。然而是不是可以更完美呢？</p><p>回顾一下平时浏览网站的情况，我们会发现两个比较有意思的结论：</p><ol><li>80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的<a href="https://en.wikipedia.org/wiki/Pareto_principle" target="_blank" rel="noopener">80/20 Rule</a>；</li><li>我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。</li></ol><p>这两条结论很容易让我们联想到<code>缓存机制</code>。如果我们将已经访问过的那些域名的解析结果缓存在自己的计算机上，那么下次访问的时候可以直接读取结果，不用再次重复DNS查询过程，给自己和域名服务器都节省了麻烦。</p><p>当然，这样做的一个前提是要缓存的解析结果不会频繁更改，也就是说我十分钟后解析一个域名的结果和现在解析的结果是一样的。对大多数域名来说，这都是一个不争的事实。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，我们在域名资源记录里面添加一个<code>Time_to_live</code>字段，表明这条记录最多可以缓存多久。对于那些“稳如泰山”的域名，给一个比较大的值，而那些“朝三暮四”的域名，则可以给定一个小的值。</p><p>我们既然可以在本机利用缓存，那么可不可以在域名服务器上也利用缓存机制呢，答案当然是可以的。因为对于域名服务器来说，上面的两条有意思的结论仍然有效。所以，域名服务器可以将那些访问过的域名资源记录缓存，用户再次发起请求时，可以直接返回缓存结果，不用去迭代或者递归解析。</p><p>关于DNS理论部分，更多内容还可以参考这两个文本：</p><ul><li><a href="https://tools.ietf.org/html/rfc1034" target="_blank" rel="noopener">RFC 1034: Domain Names - Concepts and Facilities</a></li></ul><h2 id="并没有结束"><a href="#并没有结束" class="headerlink" title="并没有结束"></a>并没有结束</h2><p>上面一大堆理论，看上去有点不明所以是吧，没事，接下来会结合实践来更加清晰地认识DNS这一最基础的系统。</p><p>其实不止是DNS，还有HTTPS、TCP、UDP这些很基础的协议，都值得我们静下心去好好认识它们。因为，写DNS之前，我以为我已经完全搞明白了它，但是写的过程发现好多地方自己根本就不知道，之前完全是停留在一个很浮夸的层面上。所以，是时候找时间好好把这些协议过一遍，用自己的语言，从<code>解决问题</code>的角度，记录下这些经典协议的故事了。</p><p>全文转载自<strong>selfboot</strong>的<a href="https://selfboot.cn/2015/11/05/dns_theory/" target="_blank" rel="noopener">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环不变式(Loop Invariant)与算法正确性</title>
      <link href="/2019/07/16/loopinvariant/"/>
      <url>/2019/07/16/loopinvariant/</url>
      
        <content type="html"><![CDATA[<p>循环不变式是让循环成立的一个statement，其必须具备三个性质：</p><ol><li>初始(Initialization)：在循环开始（第一次迭代）之前，它为真</li><li>保持(Maintenance)：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</li><li>终止(Termination)：当循环终止时（在某种条件下），不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。</li></ol><h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><p>对于插入排序来说，“A[1, …, j - 1]是有序的”这一statement是它的循环不定式。</p><p>初始：在进行第一次循环之前(j = 2)，因为仅有单个元素A[1]，因此A[1,…, j - 1]一定是有序的。</p><p>保持：因为循环将循环中的每一元素向右移动，直到此次插入的A[j]到恰当的元素。因此我们可以保证，从A[1,…, j - 1]一定是有序的。</p><p>终止：for循环终止的条件是j超出A的长度。因为每次j都是增加1，因此必会发生j&gt;A.length。那么整个数组A[1, …, j]一定是有序的</p><pre class=" language-pseudocode"><code class="language-pseudocode">Insertion-Sort(A)  for j = 2 to A.length      key = A[j]      i = j - 1      while i > 0 and A[i] > key          A[i + 1] = A[i]          i = i - 1      A[i + 1] = key</code></pre>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周六野 + 林芊妤 健身计划</title>
      <link href="/2019/06/20/wildSaturday/"/>
      <url>/2019/06/20/wildSaturday/</url>
      
        <content type="html"><![CDATA[<p>参考豆瓣鹅组原帖：<a href="https://www.douban.com/group/topic/138221315/" target="_blank" rel="noopener">https://www.douban.com/group/topic/138221315/</a></p><h3 id="Fat-Burn-Everyday"><a href="#Fat-Burn-Everyday" class="headerlink" title="Fat Burn Everyday"></a>Fat Burn Everyday</h3><p>下面是筛选出来每天一定会做的四个视频(update 2019/07/08)</p><ul><li>矫正假胯宽（周六野）<br><a href="https://www.bilibili.com/video/av24065538" target="_blank" rel="noopener">https://www.bilibili.com/video/av24065538</a></li><li>美背（周六野）<br><a href="https://www.bilibili.com/video/av27159584" target="_blank" rel="noopener">https://www.bilibili.com/video/av27159584</a></li><li>天鹅臂（美丽芭蕾）- 目前只做p1天鹅臂系列，看情况后续尝试p2拜拜肉系列XD<br><a href="https://www.bilibili.com/video/av4461931" target="_blank" rel="noopener">https://www.bilibili.com/video/av4461931</a></li><li>加强版瘦大腿（Coffee Lin）<br><a href="https://www.bilibili.com/video/av22082243" target="_blank" rel="noopener">https://www.bilibili.com/video/av22082243</a></li></ul><h3 id="一些时间充裕下的选择"><a href="#一些时间充裕下的选择" class="headerlink" title="一些时间充裕下的选择"></a>一些时间充裕下的选择</h3><ul><li>矫正驼背圆肩（周六野）<br><a href="https://www.bilibili.com/video/av9466939" target="_blank" rel="noopener">https://www.bilibili.com/video/av9466939</a></li><li>瘦小腿（周六野）<br><a href="https://www.bilibili.com/video/av15348225" target="_blank" rel="noopener">https://www.bilibili.com/video/av15348225</a></li><li>瘦腰（周六野）<br><a href="https://www.bilibili.com/video/av39155175" target="_blank" rel="noopener">https://www.bilibili.com/video/av39155175</a></li><li>瘦下腹（周六野）<br><a href="https://www.bilibili.com/video/av16199500" target="_blank" rel="noopener">https://www.bilibili.com/video/av16199500</a></li><li>瘦腿提臀（周六野）<br><a href="https://www.bilibili.com/video/av9091446" target="_blank" rel="noopener">https://www.bilibili.com/video/av9091446</a></li><li>膝超伸（周六野）<br><a href="https://www.bilibili.com/video/av10307623" target="_blank" rel="noopener">https://www.bilibili.com/video/av10307623</a></li><li>全身减脂（Coffee Lin）<br><a href="https://www.bilibili.com/video/av41871829" target="_blank" rel="noopener">https://www.bilibili.com/video/av41871829</a></li><li>Cardio Fat Burn（美丽芭蕾）<br><a href="http://www.bilibili.com/video/av5305533" target="_blank" rel="noopener">http://www.bilibili.com/video/av5305533</a></li></ul><h3 id="现在的状态"><a href="#现在的状态" class="headerlink" title="现在的状态"></a>现在的状态</h3><p><strong>2019.7.8</strong>：恢复锻炼大概十三天左右（我又划水了lol），体重依然维持50.1kg不变，但明显感觉大臂和大腿都瘦了。</p><p>大臂：进行天鹅臂两天，大臂上侧+肩膀锻炼完的时候都硬硬的，轻捏会觉得十分酸疼。但天鹅臂是我见过最有效的塑形运动，第二天的时候大臂就有明显线条。</p><p>大腿：坚持林芊纾的瘦腿加强版大概有十多天了，大腿下半部分出现了明显的缝隙。大腿积累了二十多年肥膘（还兼具假胯宽），要减下来也不是一两天的功夫。但Lin的瘦大腿还是带给我很多惊喜的，至少穿上短裤后露出的部分已经有不错的线条了。</p><p>全身：自上次记录后一直到7.3左右因为朋友来访都没有好好控制饮食，最胖的时候体重飙升到52kg（暴哭，大晚上吃烤肉真的很胖人）！从7.3来到分公司实习后，开始控制饮食，体重疯狂下降。大概三天掉了回了50.1kg，今早没撑，可能已经掉破50kg了。目前来看最感人的变化是锁骨，推测是周六野驼背圆肩的功劳？现在穿娃娃领小裙子遮手臂遮大腿系腰带显腰露出锁骨已经达到可上相胖瘦了。下一步准备放一放腰和腹部，开始瘦大臂+瘦背+（永恒的）瘦腿。对于大胸妹来说，练背性价比太高了，希望自己能看起来薄一点QAQ</p><p>饮食：<br>早餐：看心情啃最多一半的碳水包，或者吃一片全麦面包。我选择将碳水放在早上摄入，为每日脑力工作提供一点力量……<br>午餐：由于公司地理位置极其偏僻，午间有且仅有食堂作为唯一选择。食堂标配两素一荤，油水有，但因为我早晚不会摄入什么油水，所以午间摄入一点脂肪我能够接受，最底下一层最油的就不吃啦XD 午间我不会刻意摄入米饭/面条，不过如果菜里面有淀粉类食物我也不会拒绝（公司一共就三个菜少吃一/两个太影响下午工作啦）<br>晚餐：晚餐被分成两半，一半是下班后（5:30）会摄入大概50g鸡胸肉，然后开始运动，运动结束后再摄入50g鸡胸肉，或者酌情把早上没啃完的碳水包啃了。<br>饮水：没奶茶会死星人依然会每周摄入一到两杯奶茶（去冰三分糖）。日常饮水变成Mate Tea，南美洲无茶碱无咖啡因的草本植物小饮料，据说有刮油利尿的功效，也提神醒脑，促进新陈代谢。具体功效没什么感觉，但是对不喜欢喝水的我来说，自泡的茶也是一个好的替代品。</p><p>总的来说，我还是粗略地将碳水、蛋白质、脂肪的比例控制在3:3:3的（剩下1份留给蔬菜）。这个饮食目前看来效果不错，属于兼具我很快乐和我要减肥的饮食范围，然后确保一定的碳水摄入让我工作/学习不会掉链子，算是我目前能维持的最大平衡了。</p><p><strong>2019.6.19</strong>：早晨量的体重是50.1kg，由于实习住的地方没有全身镜和卷尺，没有全身图片和具体的数值，只能靠体重和肉眼来观察。<br>因为期末月五月和六月初刚回国吃吃喝喝，体重一路从47kg飙升到51kg，这几天吃得少一点在50kg起起落落，再坚持几天估计就到49kg了。暂定目标是<strong>46kg</strong>，预期在七月内达到。饮食由于实习没办法真正意义上做到减肥餐，只能做到不饿就停+少约馆子。最大的罪恶是零食和奶茶，太久没接触辣条了有点收不住，最多控制在两周一包的频率。初步计划坚持到6.30日观察成效，再做调整。</p>]]></content>
      
      
      <categories>
          
          <category> LivingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Priority Queue</title>
      <link href="/2019/06/12/heap/"/>
      <url>/2019/06/12/heap/</url>
      
        <content type="html"><![CDATA[<h1 id="Heap（Priority-Queue）"><a href="#Heap（Priority-Queue）" class="headerlink" title="Heap（Priority Queue）"></a>Heap（Priority Queue）</h1><p>优先队列（Priority Queue）是一种非常重要的数据结构，本文将讨论对于优先队列的有效实现以及优先队列的使用。一般来说，优先队列一定具有两个基本操作：插入Insert和删除最小DeleteMin。</p><h3 id="Basic-Implementation"><a href="#Basic-Implementation" class="headerlink" title="Basic Implementation"></a>Basic Implementation</h3><p>最简单的实现是<strong>简单链表</strong>（LinkedList），在链表头或者尾插入元素（O(1)），再遍历链表找到最小元素并删除（O(N)）。或者一直保持链表排序（O(N)），这样删除最小只用花费（O(1)）。</p><p>另一种实现方式是<strong>查找二叉树</strong>（Binary Search Tree）。插入是随机的，花费O(logN)的时间，删除最小则一直删除最左边的元素（O(logN)），如上时间花费都是<strong>平均时间</strong>。由于最小元素一直被删除，树的结构将被影响（最坏情况下树的深度将是其期望深度的两倍）。</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>堆（Heap）能够在O(logN)的时间内将如上两个操作完成。</p><p>堆具有<strong>结构性</strong>与<strong>堆序性</strong>两个性质，而对于堆的任意插入（Insert）和删除最小（DeleteMin）都可能破坏这两个性质。因此，我们所有对堆的操作都要维持这两个操作。</p><p><strong>结构性</strong></p><p>堆的结构是一棵Complete Binary Tree，意味着堆是个完全填满的二叉树（底层由左往右插入元素，可以不满），其高（height）为logN。因为完全二叉树的规律，我们不需要使用链表实现堆，而可以用一个普通数组实现它。<strong>对于任意在i上的元素，左儿子是2i，右儿子是2i+1，母亲是i/2</strong></p><p><strong>堆序性</strong></p><p>为了快速实现DeleteMin这一操作，我们应当始终确保最小元素在根（Root）的位置上。我们应当确保<strong>任意结点都小于他的孩子</strong>。</p><h3 id="Heap-Operations"><a href="#Heap-Operations" class="headerlink" title="Heap Operations"></a>Heap Operations</h3><p>如上文所说，优先队列（堆）有两个基本操作：Insert和DeleteMin，我们将在下文中探讨如何实现这两个基本操作。</p><p><strong>Insert</strong></p><ol><li>将插入元素插入到堆的下一个位置中（末尾指针处），如果堆的堆序性没有被破坏，那么插入完成。</li><li>如果堆的堆序性被破坏，我们交换该元素与其父节点。重复这一过程，一直到堆序性没有被破坏为止。</li></ol><p>这一过程被称作Percolate Up。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>AnyType x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>currentSize <span class="token operator">==</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>    <span class="token function">enlargeArray</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> hole <span class="token operator">=</span> currentSize<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> x<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span> hole<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>    array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>hole<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将swap需要3步的操作化简为1步</span>  <span class="token punctuation">}</span>  array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最坏情况：插入元素是最小值(O(logN))</p><p><strong>DeleteMin</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AnyType <span class="token function">deleteMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnderflowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  AnyType min <span class="token operator">=</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>currentSize<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">percolateDown</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">percolateDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> hole<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> child<span class="token punctuation">;</span>  AnyType tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> hole <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> currentSize<span class="token punctuation">;</span> hole <span class="token operator">=</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    child <span class="token operator">=</span> hole <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">!=</span> currentSize <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      child<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//ensure we use smaller child for later comparison</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>      array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//swap a[hole] and a[child]</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最坏情况：O(logN)从根下滤到最底层</p><p><strong>decreaseKey</strong></p><p>decreaseKey(p, key)降低p处的值，降低的幅度为key。降低后做一次上滤。</p><p><strong>increaseKey</strong></p><p>increaseKey(p, key)增加p处的值，增加的幅度为key。增加后做下滤。</p><p><strong>delete</strong></p><p>删除某一结点p：执行decreaseKey(p, MAX_INTEGER)，再执行deleteMin。</p><p><strong>buildHeap</strong></p><p>执行N次Inert即可。每次Insert平均时间是O(1)，最坏时间是O(logN)，所以该操作平均时间是O(N)</p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Priority Queue </tag>
            
            <tag> Heap </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and Queue</title>
      <link href="/2019/06/12/stack/"/>
      <url>/2019/06/12/stack/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><p>抽象数据类型(Abstract Data Type): 带有一组操作的一些对象的集合</p><h3 id="Stack-ADT"><a href="#Stack-ADT" class="headerlink" title="Stack ADT"></a>Stack ADT</h3><p>栈本质是个表</p><p><strong>from infix to postfix</strong></p><p>遇见操作数，放到输出队列中，遇见操作符，push进栈，按照优先级弹出（如果当前操作符的优先级比top低，那么弹出top，直至优先级高于top）</p><p>正在处理的开符号不会随便弹出</p><p>当输入为空时，将栈清空</p><p><strong>Activation Record &amp; Stack Frame </strong></p><p>tail recursion 可以被while循环消除</p><p>while循环模拟递归调用</p><p>递归总能够消除，一般是使用stack。一般非递归程序比等价递归快，但是牺牲了清晰度</p><h3 id="Queue-ADT"><a href="#Queue-ADT" class="headerlink" title="Queue ADT"></a>Queue ADT</h3><p>queue的本质也是表，可以用array实现</p><p>也可以用circular array实现</p><p><strong>file server</strong></p><p>queueing theory</p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodingStyle(Updated Java Google Coding Style)</title>
      <link href="/2019/06/06/CodingStyle/"/>
      <url>/2019/06/06/CodingStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Coding-Style"><a href="#Java-Coding-Style" class="headerlink" title="Java Coding Style"></a>Java Coding Style</h1><p>Based on Google Java Coding Style, I took some notes about these <strong>hard and fast rules</strong>. </p><h4 id="Class-Declaration"><a href="#Class-Declaration" class="headerlink" title="Class Declaration"></a>Class Declaration</h4><ul><li>Exactly one top-level class declaration</li><li>Ordering of class contents: When a class has multiple constructors, or multiple methods with the same name, these appear sequentially, with no other code in between</li></ul><h4 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h4><ul><li>Braces are used with <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code> and <code>while</code> statements, even when the body is empty or contains only a single statement</li><li>No line break before the opening brace; line break after the opening brace; line break before the closing brace; line break after the closing brace</li><li>Empty blocks may be concise</li><li>One statement per line</li><li>Column limit: 100 characters (any unicode code point) - exceeded code should be line-wrapped</li><li>Every variable declaration declares only one variable </li><li>Dont’ forget initializing local variables!!!!</li><li>Class names are written in UpperCamelCase</li><li>Method names are written in lowerCamelCase</li><li>Constant names use all uppercase letters</li><li>Non-constant field names are written in lowerCamelCase</li><li>Parameter names are written in lowerCamelCase</li><li>Local variable names are written in lowerCamelCase</li></ul><h1 id="Principles-of-Good-Programming"><a href="#Principles-of-Good-Programming" class="headerlink" title="Principles of Good Programming"></a>Principles of Good Programming</h1><ul><li>DRY(Don’t Repeat Yourself): avoid repetition </li><li>Abstraction: Each significant piece of functionality in a program should be implemented in just one place in the source code</li><li>Keep it simple, stupid! Simplicity should always be a key goal</li><li>Avoid creating a YAGNI(<strong>You aren’t going to need it</strong>):  try not to add functionality until you need it</li><li>Easy read and understood</li><li><strong>open/closed</strong> open for extension but closed for modification</li><li>Write code for the maintainer</li><li>Single Responsibility Principle: A component of code (e.g. class or function) should perform a single well defined task</li><li>Minimize coupling &amp; Maximize cohesion </li><li>Hide implementation details</li><li>Law of Demeter: code components should only communicate with their direct relations (e.g. classes that they inherit from, objects that they contain, objects passed by argument, etc.)</li><li>Avoid premature optimization: optimize the code after finishing them</li><li>Separation of concerns</li></ul><p>Source：<a href="https://www.kevinlondon.com/2015/05/05/code-review-best-practices.html" target="_blank" rel="noopener">https://www.kevinlondon.com/2015/05/05/code-review-best-practices.html</a></p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="/2019/06/04/tree/"/>
      <url>/2019/06/04/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h3 id="Volcabulary"><a href="#Volcabulary" class="headerlink" title="Volcabulary"></a>Volcabulary</h3><p>Tree: A connected, acycinc, undirected graph.</p><p>Degree of node: The number of children of a node </p><p>External node: leaves</p><p>Internal node: other nodes</p><p>Path: a unique, non-repeating path from r to n (we can use this sequence to define descendents and ancestors)</p><p>Depth(level)</p><p>Maximum depth = height</p><p>Path length: the sum of the levels of all nodes</p><p>External path length: the sum of the levels of external nodes</p><p>Internal path length: the sum of the levels of internal nodes</p><h3 id="Representations"><a href="#Representations" class="headerlink" title="Representations"></a>Representations</h3><p><strong>Root - down </strong></p><p>key implementation: siblings and children (degree!)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">treeSum</span><span class="token punctuation">(</span>Tree<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> sum<span class="token punctuation">;</span>  sum <span class="token operator">=</span> tree<span class="token punctuation">.</span><span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tree<span class="token punctuation">.</span><span class="token function">degree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span>    sum <span class="token operator">+=</span> <span class="token function">treeSum</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token function">child</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>Leaf - up</strong></p><p>key implementation: parent</p><p>Array representation (binary tree):</p><ul><li>parent for k-th node: (k-1)/2</li><li>left child for k-th node: 2k + 1</li><li>right child for k-th node: 2k + 2</li></ul><h3 id="Tree-Traversals"><a href="#Tree-Traversals" class="headerlink" title="Tree Traversals"></a>Tree Traversals</h3><p>Traversals in an iterative way</p><p>In Java, we implement tree by an array. Thus, we must visit the root firstly, then, we visit its left child and its right child.  (If one child is null, it will show null.) </p><p>If the array has the length n, we know the height of the tree is logn. </p><p><strong>Preorder</strong> (DFS)</p><p>Used to create a copy of the tree</p><p>Root - Left -Right </p><p>It is in the same order of the array.</p><p>对于每一次visit：</p><p>1.首先将其value加入到输出队列中</p><p>2.检查left child，如果不为空，visit left</p><p>3.检查right child，如果不为空，visit right</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  preorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>N-ary</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            preorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Node c <span class="token operator">:</span> node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p><strong>Inorder</strong></p><p>In inorder sequence, we can find out all elements on left side of ‘Root’ are in left subtree and elements onright side of ‘Root’ are in right subtree.</p><p>In BST, the inorder sequence gives nodes in non-decreasing order. </p><p>Left - Root - Right </p><p>对于每一次visit:</p><p>1.如果有left child，将left child加入到stack中，visit left child，直到没有left child</p><p>2.将value加入到array中</p><p>3.如果有right child，visit right child（然后重复第一步）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  <span class="token punctuation">}</span>     TreeNode visitedNode <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  inorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>visitedNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  node <span class="token operator">=</span> visitedNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>Postorder</strong> (reverse of preorder)</p><p>Used to delete the tree</p><p>Left - Right - Root </p><p>对于每一次visit：</p><p>1.当node不为空时，将node.right和node加入到stack中，node = node.left</p><p>2.从stack中取第一个node，如果node.right != null并且node.right = stack.peek()，使node等于stack的第一个node，并且将原node放回到stack；否则，把node加入到输出队列中并使其为空</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TreeNode visited <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode tmp <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>tmp <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>visited<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> visited<span class="token punctuation">.</span>right <span class="token operator">==</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>visited<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                postorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>visited<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>Reverse of preorder</p><pre class=" language-java"><code class="language-java">        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            postorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>N-ary </p><pre class=" language-java"><code class="language-java">        Stack<span class="token operator">&lt;</span>Node<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            postorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Node c <span class="token operator">:</span> node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>Level Traversal</strong></p><p>level traversal: all of them use <strong>Queue</strong> class to implement (BFS)</p><p>zigzag traversal - set a flag to decide the adding order</p><p><strong>Vertical Traversal</strong></p><p><strong>Tree Construction</strong></p><p><strong>Preorder + Inorder</strong></p><p><strong>Inorder + Postorder</strong></p><p><strong>Postorder + Preorder</strong></p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bread-First-Search and Depth-First-Search</title>
      <link href="/2019/05/01/DFS/"/>
      <url>/2019/05/01/DFS/</url>
      
        <content type="html"><![CDATA[<h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><p>一般图算法的输入：|V| 和 |E| （G = (V, E)）<br>图的表示：</p><ul><li>链表：多用于稀疏图，即|E|远小于|V|^2。对于有向图来说，所有链表长度和为|E|；对于无向图来说，所有链表长度和为2|E|。链表占用空间O(V+E)。链表无法快速判断有无包含一条edge，因此我们引入矩阵。</li><li>矩阵：多用于稠密图，即即|E|接近|V|^2。矩阵占用空间O(V^2)。无向图可以只存对角线以上部分，因而减少储存空间。</li></ul><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth - First - Search"></a>Depth - First - Search</h3><p>深度优先搜索会尽可能的深入，总是从最近发现的结点v的出发边进行探索，直到该结点所有出发边都被发现为止。一旦所有出发边都被发现，则回溯到v的前驱结点u，搜索该结点的所有出发边。此过程一直重复，知道所有可到达结点都被到达。如果图中仍有未发现结点，随机挑选另一source vertex进行探索，直到图中没有任何未发现结点。深度优先算法将生成<strong>深度优先森林</strong>。<br>初始结点是白色，被发现后变为灰色，邻接链表被扫描完成变为黑色。此方法保证每个结点只会在深度优先树中出现一次。<br>深度优先的特殊属性：<strong>时间戳（Time Stamp）</strong>v.d 记录结点第一次发现的时间（变灰的时间），v.f记录结点扫描完成的时间（变黑的时间），对于每一个结点我们有：v.f &gt; v.d</p><pre class=" language-pse"><code class="language-pse">DFS(G)for each vertex u ∈ G.V    u.color = White    u.pi = Niltime = 0for each vertex v ∈ G.V    if v.color = White        DFS-VISIT(G, v)DFS-VISIT(G, v)time = time + 1v.d = timev.color = Grayfor each u ∈ G.adj(v)    if u.color = White        u.pi = v        GFS-VISIT(G, u)v.color = Blacktime = time + 1v.f = time</code></pre><p>O(V + E)<br>深度优先的性质（properties）</p><ul><li>图结构：其生成的前驱子图G‘形成一个深度森林（深度优先树的结构与DFS-VISIT的调用结构完全相似，只有v在链表中被发现的适合，u才成为v的前驱（在u为灰色时间段里发现））</li><li>发现时间和完成时间具有括号化结构（parenthesis structure），左括号是发现时间，右括号是结束时间。well-formed expression</li><li>Parenthesis Theorem: <ul><li>[u.d, u.f] and [v.d, v.f] are entirely disjoint, and neither u nor v is a descendant of the other</li><li>[u.d, u.f] is contained entirely within the [v.d, v.f], u is a descendant of v</li><li>[v.d, v.f] is contained entirely within the [u.d, u.f], v is a descendant of u</li></ul></li><li>White - Path Theorem: vertex u 是 vertex v的后代，当且仅当v被发现的时候，有一条从v到u都是白色结点的路径</li></ul><p><strong>Topological Sort</strong></p><p>G中所有结点的线性次序，如果G包含边（u, v），则结点u在拓扑排序中处于结点v的前面（必须无环），因为u有一条边指向v，则u的结束时间一定比v晚，u的次序也一定比v前</p><pre class=" language-pseudocode"><code class="language-pseudocode">TOPOLOGICAL-SORT(G)call DFS(G) to compute finishing time v.f for each vas each vertex is finished, insert it onto the front of a linked listreturn the linked list</code></pre><p>O(V + E), 因为DFS需要此时间完成。插入linkedlist时间是O(1*V)<br><strong>Correctness</strong>：</p><ul><li>一个有向图（directed graph）是无环(acyclic graph)的当且仅当对其进行深度搜索不产生后向边</li><li>拓扑排序生成的是有向无环图的拓扑排序 - 所以有向无环图一定可以生成一个现行次序</li></ul><p><strong>Strong Connected Components</strong></p><p>DFS can decompose a directed graph into its strongly connected components. (By two DFS) SCC will be start states for many graph algorithms. <strong>Strong Connected Components (SCC)</strong> of a directed graph G is a maximal set of vertices C ⊆ V such that for every pair of vertices u and v in C, we have both u -&gt; v and v -&gt; u (u and v are reachable from each other).<br>G and the transpose of G share the same SCC. 强连通分量可以收缩成一个结点（用一个结点替换整个连通分量），这样的浓缩分量图G’是无环的。</p><p>To find SCC:<br>Use the transpose of G. G’ = (V, E’), where E’ contains the edges of G with their directions reversed. Time to create G’: O(V + E).</p><pre class=" language-pseudocode"><code class="language-pseudocode">SCC(G)call DFS(G) to compute finishing times u.f for each vertex ucompute G^Tcall DFS(G^T), but in the main loop of DFS, consider the verticesin order of decreasing u:f (as computed in line 1) 'Visit the G^T in the topological sort order'output the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component</code></pre><p>Propoerty:</p><ul><li><strong>Component Graph GSCC</strong> 将SCC的所有结点收缩到一起，构建出GSCC分量图</li><li>如果C和C’是有向图G的两个不同SCC，假设C有u和v，C‘有u’和v‘，如果G包含一条从u到u’的路径，按么G不可能包含另一条从v到v‘的路径（因为u和v，u‘和v’是互通的）</li><li>因为按照Topological sort order进行第二次DFS，因此我们可以推广时间的概念到SCC上。对于每一个SCC，定义d是最早发现的时间，即min(u.d)，f是最晚完成的时间，即max(u.f)。C和C‘是G的两个SCC，如果存在一条边(u,v)从C到C‘，则f(C) &gt; f(C’). 如果(u,v）存在于transpose G中，我们有f(C) &lt; f(C’) (路径是从C’到C的)</li></ul><h3 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth - First - Search"></a>Breadth - First - Search</h3><p>输入：G(V,E) and s</p><ul><li><p>以s为根结点，找寻所有可以从s到达的结点</p></li><li><p>计算s与其可到达节点的距离</p></li><li>输出广度优先树</li><li>广度优先树在未探索距离s为k距离的结点之前，一定不会探索（k+1）距离的结点。</li><li>广度：沿着已发现结点和未发现结点的边界向外探索（广）</li><li>Q管理的是所有灰色结点。灰色和黑色都是已经发现的结点，唯一的不同是，灰色代表白色和黑色的边界。</li><li>O(V+E)</li></ul><p>最短路径与BFS</p><p><strong>LeetCode Practical Experience</strong> </p><p>相较于Recursive solution，依靠Queue实现Iterative BFS能够节省大量的空间</p><p>N-ary Tree 的实现</p><pre class=" language-java"><code class="language-java">Public <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> val<span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>Node<span class="token operator">></span> children<span class="token punctuation">;</span><span class="token punctuation">}</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//get a unchangeable value</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Implement some operations for each node here</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>Node c <span class="token operator">:</span> node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>      q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//add node's children into queue</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//Implement some operations for each level here</span><span class="token punctuation">}</span></code></pre><p>从左到右与从右到左添加children：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//For binary tree </span><span class="token comment" spellcheck="true">//from left to right: </span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//from right to left:</span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>一些注意事项：</p><ul><li>分清楚<code>Node</code>和<code>TreeNode</code></li><li>善用Integer.MIN_VALUE和Integer.MAX_VALUE（对于负值，0会输出错误答案）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic OCmal</title>
      <link href="/2019/04/12/ocamlbasics/"/>
      <url>/2019/04/12/ocamlbasics/</url>
      
        <content type="html"><![CDATA[<h1 id="Basic-OCaml-Notes"><a href="#Basic-OCaml-Notes" class="headerlink" title="Basic OCaml Notes"></a>Basic OCaml Notes</h1><p>Compilation</p><p><code>xxx.ml</code> -&gt; <code>ocamlbuild xxx.native</code> -&gt; <code>./xxx.native</code></p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><strong>Calling functions</strong></p><p>No brackets and no comma between the arguments</p><p>（ “hello”, 3 ）is type of （’a * ‘ b）</p><p><strong>Define functions</strong></p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> average a b <span class="token operator">=</span>     <span class="token punctuation">(</span>a<span class="token operator">+.</span> b<span class="token punctuation">)</span> <span class="token operator">/.</span> <span class="token number">2.0</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(*val average: float -> float -> float = &lt;fun>*)</span></code></pre><ol><li>OCaml is a strongly <em>statically typed</em> languageå</li><li>OCaml uses <em>type inference</em> to work out the types, so you don’t have to.</li><li>OCaml doesn’t do any implicit casting. If you want a float, you have to write <code>2.0</code>because <code>2</code> is an integer. <strong>No automatic conversion</strong></li><li>As a side-effect of type inference in OCaml, functions (including operators) can’t have overloaded definitions. OCaml defines <code>+</code> as the <em>integer</em> addition function. To add floats, use <code>+.</code> (note the trailing period). Similarly, use <code>-.</code>, <code>*.</code>, <code>/.</code> for other float operations</li><li>OCaml doesn’t have a <code>return</code> keyword — the last expression in a function becomes the result of the function automatically.</li></ol><p><strong>Recursive Functions</strong></p><p> <code>let rect</code> - please explicitly say</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> range a b <span class="token operator">=</span>     <span class="token keyword">if</span> a <span class="token operator">></span> b <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">else</span> a <span class="token punctuation">:</span><span class="token punctuation">:</span> range <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> b<span class="token comment" spellcheck="true">(*val range: int -> int -> int list = fun*)</span></code></pre><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Int    31-bit signed int - 32 processors / 63-bit signed int - 64 processors</p><p>​        use 1 bit to automatically manage the memory use (garbage collection)</p><p>​        no unsigned interger type - using <code>nativeint</code></p><p>Float    IEEE double-precison (same as C)</p><p>Bool    true or false</p><p>Char    8-bit char (dont support Unicode or UTF-8) <strong>Serious flaw</strong></p><p>Unit    written as ( ) (same as void in C)</p><p><strong>Never</strong> implicit casts - <code>1+2.5</code> is a type error - <code>+</code> operator requires two ints as arguments. </p><p><code>(float_of_int i) +. f</code> - shorter alias: <code>float i +. f</code></p><p>Implicit vs. explicit casting? which is better?</p><ol><li>Type reference is such a wondeful time-saving feature</li><li>errors caused by implicit casts are hard to find</li><li>Some casts are expensive operations (i.e. int <-> float)</-></li></ol><h3 id="Types-of-Functions"><a href="#Types-of-Functions" class="headerlink" title="Types of Functions"></a>Types of Functions</h3><p>Because of type inference you will rarely if ever need to explicitly write down the type of functions.</p><p><strong>currying</strong>: <code>f: arg1 -&gt; arg2 -&gt; ... -&gt; argn -&gt; returnType</code></p><p>If return nothing (void): <code>output_char: out_channel -&gt; char -&gt; unit</code></p><p><strong>polymorphic functions</strong> take anything as an argument</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> give<span class="token punctuation">_</span>me<span class="token punctuation">_</span>a<span class="token punctuation">_</span>three x <span class="token operator">=</span> <span class="token number">3</span><span class="token comment" spellcheck="true">(*give_me_a_three: 'a -> int*)</span></code></pre><p><code>&#39;a</code> means <strong>any type</strong></p><p><strong>Type Inference</strong></p><p>Dont need to <strong>declare</strong> the types of functions and variables.</p><p>OCaml figures them out &amp;&amp; checks all types match up (even across different files!) </p><h3 id="Structure-of-OCaml"><a href="#Structure-of-OCaml" class="headerlink" title="Structure of OCaml"></a>Structure of OCaml</h3><p><strong>Local “Variables”</strong></p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> average a b <span class="token operator">=</span>     <span class="token keyword">let</span> sum <span class="token operator">=</span> a <span class="token operator">+.</span> b <span class="token keyword">in</span>         sum <span class="token operator">/.</span> <span class="token number">2.0</span><span class="token comment" spellcheck="true">(*val average: float -> float -> float = &lt;fun>*)</span></code></pre><p><code>let name = expression in</code> define a named local expression, and <code>name</code> can then be used later on in the function instead of <code>expression</code>, till a <code>;;</code></p><p>This <code>sum</code> is just a shorthand name for the expression <code>a +.b</code>, you can’t assign it later or change its value in any way. </p><p><strong>Global “Variables”</strong></p><p>Define at the top level - still a shorthand name for things</p><p><strong>Let-bindings</strong></p><p>Reference: a real variable. (It is better to create a reference and <strong>name</strong> it)</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> my<span class="token punctuation">_</span>ref <span class="token operator">=</span> ref <span class="token number">0</span><span class="token comment" spellcheck="true">(*val my_ref: int ref = {contents = 0}*)</span>my<span class="token punctuation">_</span>ref <span class="token operator">:=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(* unit = ()*)</span><span class="token operator">!</span>my<span class="token punctuation">_</span>ref<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(*int = 100*)</span></code></pre><p><code>:=</code> is used to assign, <code>!</code> dereferences </p><p><strong>Nested Functions</strong></p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> read<span class="token punctuation">_</span>whole<span class="token punctuation">_</span>channel chan <span class="token operator">=</span>    <span class="token keyword">let</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span>create <span class="token number">4096</span> <span class="token keyword">in</span>    <span class="token keyword">let</span> <span class="token keyword">rec</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>      <span class="token keyword">let</span> newline <span class="token operator">=</span> input<span class="token punctuation">_</span>line chan <span class="token keyword">in</span>      Buffer<span class="token punctuation">.</span>add<span class="token punctuation">_</span>string buf newline<span class="token punctuation">;</span>      Buffer<span class="token punctuation">.</span>add<span class="token punctuation">_</span>char buf <span class="token string">'\n'</span><span class="token punctuation">;</span>      loop <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">in</span>    <span class="token keyword">try</span>      loop <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">with</span>      End<span class="token punctuation">_</span>of<span class="token punctuation">_</span>file <span class="token operator">-></span> Buffer<span class="token punctuation">.</span>contents buf<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">val</span> read<span class="token punctuation">_</span>whole<span class="token punctuation">_</span>channel <span class="token punctuation">:</span> in<span class="token punctuation">_</span>channel <span class="token operator">-></span> string <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token keyword">fun</span><span class="token operator">></span></code></pre><p><code>let name arguments = function-definition in</code> </p><p><strong>Match</strong></p><p><code>match foo with ...</code></p><p>The following code is perfectly legal and all do the same thing</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> f x b y <span class="token operator">=</span> <span class="token keyword">if</span> b <span class="token keyword">then</span> x<span class="token operator">+</span>y <span class="token keyword">else</span> x<span class="token operator">+</span><span class="token number">0</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">if</span> b <span class="token keyword">then</span> y <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">match</span> b <span class="token keyword">with</span> <span class="token boolean">true</span> <span class="token operator">-></span> y <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">-></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">let</span> g z <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token boolean">true</span> <span class="token operator">-></span> z <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">-></span> <span class="token number">0</span> <span class="token keyword">in</span> g y b<span class="token punctuation">)</span><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">fun</span> x <span class="token operator">-></span> <span class="token keyword">fun</span> b <span class="token operator">-></span> <span class="token keyword">fun</span> y <span class="token operator">-></span> <span class="token keyword">if</span> b <span class="token keyword">then</span> x<span class="token operator">+</span>y <span class="token keyword">else</span> x<span class="token operator">+</span><span class="token number">0</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">_</span> <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">3</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> b <span class="token keyword">then</span> y <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(* val f : int -> bool -> int -> int = &lt;fun> *)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCmal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
