<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>周六野 + 林芊妤 健身计划</title>
      <link href="/2019/06/20/wildSaturday/"/>
      <url>/2019/06/20/wildSaturday/</url>
      
        <content type="html"><![CDATA[<p>参考豆瓣鹅组原帖：<a href="https://www.douban.com/group/topic/138221315/" target="_blank" rel="noopener">https://www.douban.com/group/topic/138221315/</a></p><h3 id="先贴视频"><a href="#先贴视频" class="headerlink" title="先贴视频"></a>先贴视频</h3><ul><li>矫正驼背圆肩<br><a href="https://www.bilibili.com/video/av9466939" target="_blank" rel="noopener">https://www.bilibili.com/video/av9466939</a></li><li>瘦小腿<br><a href="https://www.bilibili.com/video/av15348225" target="_blank" rel="noopener">https://www.bilibili.com/video/av15348225</a></li><li>瘦腰<br><a href="https://www.bilibili.com/video/av39155175" target="_blank" rel="noopener">https://www.bilibili.com/video/av39155175</a></li><li>瘦下腹<br><a href="https://www.bilibili.com/video/av16199500" target="_blank" rel="noopener">https://www.bilibili.com/video/av16199500</a></li><li>瘦腿提臀<br><a href="https://www.bilibili.com/video/av9091446" target="_blank" rel="noopener">https://www.bilibili.com/video/av9091446</a></li><li>矫正假胯宽<br><a href="https://www.bilibili.com/video/av24065538" target="_blank" rel="noopener">https://www.bilibili.com/video/av24065538</a></li><li>膝超伸<br><a href="https://www.bilibili.com/video/av10307623" target="_blank" rel="noopener">https://www.bilibili.com/video/av10307623</a></li><li>周末薅一个Coffee Lin的全身消脂<br><a href="https://www.bilibili.com/video/av41871829" target="_blank" rel="noopener">https://www.bilibili.com/video/av41871829</a></li><li>周末再薅一个Coffe Lin的瘦腿<br><a href="https://www.bilibili.com/video/av22082243" target="_blank" rel="noopener">https://www.bilibili.com/video/av22082243</a></li><li>美背（后期替补计划）<br><a href="https://www.bilibili.com/video/av27159584" target="_blank" rel="noopener">https://www.bilibili.com/video/av27159584</a></li></ul><h3 id="现在的状态"><a href="#现在的状态" class="headerlink" title="现在的状态"></a>现在的状态</h3><p>今天（2019.6.19）早晨量的体重是50.1kg，由于实习住的地方没有全身镜和卷尺，没有全身图片和具体的数值，只能靠体重和肉眼来观察。<br>因为期末月五月和六月初刚回国吃吃喝喝，体重一路从47kg飙升到51kg，这几天吃得少一点在50kg起起落落，再坚持几天估计就到49kg了。暂定目标是<strong>46kg</strong>，预期在七月内达到。饮食由于实习没办法真正意义上做到减肥餐，只能做到不饿就停+少约馆子。最大的罪恶是零食和奶茶，太久没接触辣条了有点收不住，最多控制在两周一包的频率。初步计划坚持到6.30日观察成效，再做调整。</p>]]></content>
      
      
      <categories>
          
          <category> LivingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Priority Queue</title>
      <link href="/2019/06/12/heap/"/>
      <url>/2019/06/12/heap/</url>
      
        <content type="html"><![CDATA[<h1 id="Heap（Priority-Queue）"><a href="#Heap（Priority-Queue）" class="headerlink" title="Heap（Priority Queue）"></a>Heap（Priority Queue）</h1><p>优先队列（Priority Queue）是一种非常重要的数据结构，本文将讨论对于优先队列的有效实现以及优先队列的使用。一般来说，优先队列一定具有两个基本操作：插入Insert和删除最小DeleteMin。</p><h3 id="Basic-Implementation"><a href="#Basic-Implementation" class="headerlink" title="Basic Implementation"></a>Basic Implementation</h3><p>最简单的实现是<strong>简单链表</strong>（LinkedList），在链表头或者尾插入元素（O(1)），再遍历链表找到最小元素并删除（O(N)）。或者一直保持链表排序（O(N)），这样删除最小只用花费（O(1)）。</p><p>另一种实现方式是<strong>查找二叉树</strong>（Binary Search Tree）。插入是随机的，花费O(logN)的时间，删除最小则一直删除最左边的元素（O(logN)），如上时间花费都是<strong>平均时间</strong>。由于最小元素一直被删除，树的结构将被影响（最坏情况下树的深度将是其期望深度的两倍）。</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>堆（Heap）能够在O(logN)的时间内将如上两个操作完成。</p><p>堆具有<strong>结构性</strong>与<strong>堆序性</strong>两个性质，而对于堆的任意插入（Insert）和删除最小（DeleteMin）都可能破坏这两个性质。因此，我们所有对堆的操作都要维持这两个操作。</p><p><strong>结构性</strong></p><p>堆的结构是一棵Complete Binary Tree，意味着堆是个完全填满的二叉树（底层由左往右插入元素，可以不满），其高（height）为logN。因为完全二叉树的规律，我们不需要使用链表实现堆，而可以用一个普通数组实现它。<strong>对于任意在i上的元素，左儿子是2i，右儿子是2i+1，母亲是i/2</strong></p><p><strong>堆序性</strong></p><p>为了快速实现DeleteMin这一操作，我们应当始终确保最小元素在根（Root）的位置上。我们应当确保<strong>任意结点都小于他的孩子</strong>。</p><h3 id="Heap-Operations"><a href="#Heap-Operations" class="headerlink" title="Heap Operations"></a>Heap Operations</h3><p>如上文所说，优先队列（堆）有两个基本操作：Insert和DeleteMin，我们将在下文中探讨如何实现这两个基本操作。</p><p><strong>Insert</strong></p><ol><li>将插入元素插入到堆的下一个位置中（末尾指针处），如果堆的堆序性没有被破坏，那么插入完成。</li><li>如果堆的堆序性被破坏，我们交换该元素与其父节点。重复这一过程，一直到堆序性没有被破坏为止。</li></ol><p>这一过程被称作Percolate Up。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>AnyType x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>currentSize <span class="token operator">==</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>    <span class="token function">enlargeArray</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> hole <span class="token operator">=</span> currentSize<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> x<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span> hole<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>    array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>hole<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将swap需要3步的操作化简为1步</span>  <span class="token punctuation">}</span>  array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最坏情况：插入元素是最小值(O(logN))</p><p><strong>DeleteMin</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AnyType <span class="token function">deleteMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnderflowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  AnyType min <span class="token operator">=</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>currentSize<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">percolateDown</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">percolateDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> hole<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> child<span class="token punctuation">;</span>  AnyType tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> hole <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> currentSize<span class="token punctuation">;</span> hole <span class="token operator">=</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    child <span class="token operator">=</span> hole <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">!=</span> currentSize <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      child<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//ensure we use smaller child for later comparison</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>      array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//swap a[hole] and a[child]</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最坏情况：O(logN)从根下滤到最底层</p><p><strong>decreaseKey</strong></p><p>decreaseKey(p, key)降低p处的值，降低的幅度为key。降低后做一次上滤。</p><p><strong>increaseKey</strong></p><p>increaseKey(p, key)增加p处的值，增加的幅度为key。增加后做下滤。</p><p><strong>delete</strong></p><p>删除某一结点p：执行decreaseKey(p, MAX_INTEGER)，再执行deleteMin。</p><p><strong>buildHeap</strong></p><p>执行N次Inert即可。每次Insert平均时间是O(1)，最坏时间是O(logN)，所以该操作平均时间是O(N)</p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Priority Queue </tag>
            
            <tag> Heap </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and Queue</title>
      <link href="/2019/06/12/stack/"/>
      <url>/2019/06/12/stack/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><p>抽象数据类型(Abstract Data Type): 带有一组操作的一些对象的集合</p><h3 id="Stack-ADT"><a href="#Stack-ADT" class="headerlink" title="Stack ADT"></a>Stack ADT</h3><p>栈本质是个表</p><p><strong>from infix to postfix</strong></p><p>遇见操作数，放到输出队列中，遇见操作符，push进栈，按照优先级弹出（如果当前操作符的优先级比top低，那么弹出top，直至优先级高于top）</p><p>正在处理的开符号不会随便弹出</p><p>当输入为空时，将栈清空</p><p><strong>Activation Record &amp; Stack Frame </strong></p><p>tail recursion 可以被while循环消除</p><p>while循环模拟递归调用</p><p>递归总能够消除，一般是使用stack。一般非递归程序比等价递归快，但是牺牲了清晰度</p><h3 id="Queue-ADT"><a href="#Queue-ADT" class="headerlink" title="Queue ADT"></a>Queue ADT</h3><p>queue的本质也是表，可以用array实现</p><p>也可以用circular array实现</p><p><strong>file server</strong></p><p>queueing theory</p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodingStyle</title>
      <link href="/2019/06/06/CodingStyle/"/>
      <url>/2019/06/06/CodingStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="Principles-of-Good-Programming"><a href="#Principles-of-Good-Programming" class="headerlink" title="Principles of Good Programming"></a>Principles of Good Programming</h1><ul><li>DRY(Don’t Repeat Yourself): avoid repetition </li><li>Abstraction: Each significant piece of functionality in a program should be implemented in just one place in the source code</li><li>Keep it simple, stupid! Simplicity should always be a key goal</li><li>Avoid creating a YAGNI(<strong>You aren’t going to need it</strong>):  try not to add functionality until you need it</li><li>Easy read and understood</li><li><strong>open/closed</strong> open for extension but closed for modification</li><li>Write code for the maintainer</li><li>Single Responsibility Principle: A component of code (e.g. class or function) should perform a single well defined task</li><li>Minimize coupling &amp; Maximize cohesion </li><li>Hide implementation details</li><li>Law of Demeter: code components should only communicate with their direct relations (e.g. classes that they inherit from, objects that they contain, objects passed by argument, etc.)</li><li>Avoid premature optimization: optimize the code after finishing them</li><li>Separation of concerns</li></ul><p><a href="https://www.kevinlondon.com/2015/05/05/code-review-best-practices.html" target="_blank" rel="noopener">https://www.kevinlondon.com/2015/05/05/code-review-best-practices.html</a></p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> General </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="/2019/06/04/tree/"/>
      <url>/2019/06/04/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h3 id="Volcabulary"><a href="#Volcabulary" class="headerlink" title="Volcabulary"></a>Volcabulary</h3><p>Tree: A connected, acycinc, undirected graph.</p><p>Degree of node: The number of children of a node </p><p>External node: leaves</p><p>Internal node: other nodes</p><p>Path: a unique, non-repeating path from r to n (we can use this sequence to define descendents and ancestors)</p><p>Depth(level)</p><p>Maximum depth = height</p><p>Path length: the sum of the levels of all nodes</p><p>External path length: the sum of the levels of external nodes</p><p>Internal path length: the sum of the levels of internal nodes</p><h3 id="Representations"><a href="#Representations" class="headerlink" title="Representations"></a>Representations</h3><p><strong>Root - down </strong></p><p>key implementation: siblings and children (degree!)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">treeSum</span><span class="token punctuation">(</span>Tree<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> sum<span class="token punctuation">;</span>  sum <span class="token operator">=</span> tree<span class="token punctuation">.</span><span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tree<span class="token punctuation">.</span><span class="token function">degree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span>    sum <span class="token operator">+=</span> <span class="token function">treeSum</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token function">child</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>Leaf - up</strong></p><p>key implementation: parent</p><p>Array representation (binary tree):</p><ul><li>parent for k-th node: (k-1)/2</li><li>left child for k-th node: 2k + 1</li><li>right child for k-th node: 2k + 2</li></ul><h3 id="Tree-Traversals"><a href="#Tree-Traversals" class="headerlink" title="Tree Traversals"></a>Tree Traversals</h3><p>Traversals in an iterative way</p><p>In Java, we implement tree by an array. Thus, we must visit the root firstly, then, we visit its left child and its right child.  (If one child is null, it will show null.) </p><p>If the array has the length n, we know the height of the tree is logn. </p><p><strong>Preorder</strong> (DFS)</p><p>Used to create a copy of the tree</p><p>Root - Left -Right </p><p>It is in the same order of the array.</p><p>对于每一次visit：</p><p>1.首先将其value加入到输出队列中</p><p>2.检查left child，如果不为空，visit left</p><p>3.检查right child，如果不为空，visit right</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  preorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>N-ary</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            preorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Node c <span class="token operator">:</span> node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p><strong>Inorder</strong></p><p>In inorder sequence, we can find out all elements on left side of ‘Root’ are in left subtree and elements onright side of ‘Root’ are in right subtree.</p><p>In BST, the inorder sequence gives nodes in non-decreasing order. </p><p>Left - Root - Right </p><p>对于每一次visit:</p><p>1.如果有left child，将left child加入到stack中，visit left child，直到没有left child</p><p>2.将value加入到array中</p><p>3.如果有right child，visit right child（然后重复第一步）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  <span class="token punctuation">}</span>     TreeNode visitedNode <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  inorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>visitedNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  node <span class="token operator">=</span> visitedNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>Postorder</strong> (reverse of preorder)</p><p>Used to delete the tree</p><p>Left - Right - Root </p><p>对于每一次visit：</p><p>1.当node不为空时，将node.right和node加入到stack中，node = node.left</p><p>2.从stack中取第一个node，如果node.right != null并且node.right = stack.peek()，使node等于stack的第一个node，并且将原node放回到stack；否则，把node加入到输出队列中并使其为空</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TreeNode visited <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode tmp <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>tmp <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>visited<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> visited<span class="token punctuation">.</span>right <span class="token operator">==</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>visited<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                postorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>visited<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>Reverse of preorder</p><pre class=" language-java"><code class="language-java">        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            postorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>N-ary </p><pre class=" language-java"><code class="language-java">        Stack<span class="token operator">&lt;</span>Node<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            postorder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Node c <span class="token operator">:</span> node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>Level Traversal</strong></p><p>level traversal: all of them use <strong>Queue</strong> class to implement (BFS)</p><p>zigzag traversal - set a flag to decide the adding order</p><p><strong>Vertical Traversal</strong></p><p><strong>Tree Construction</strong></p><p><strong>Preorder + Inorder</strong></p><p><strong>Inorder + Postorder</strong></p><p><strong>Postorder + Preorder</strong></p>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bread-First-Search and Depth-First-Search</title>
      <link href="/2019/05/01/DFS/"/>
      <url>/2019/05/01/DFS/</url>
      
        <content type="html"><![CDATA[<h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><p>一般图算法的输入：|V| 和 |E| （G = (V, E)）<br>图的表示：</p><ul><li>链表：多用于稀疏图，即|E|远小于|V|^2。对于有向图来说，所有链表长度和为|E|；对于无向图来说，所有链表长度和为2|E|。链表占用空间O(V+E)。链表无法快速判断有无包含一条edge，因此我们引入矩阵。</li><li>矩阵：多用于稠密图，即即|E|接近|V|^2。矩阵占用空间O(V^2)。无向图可以只存对角线以上部分，因而减少储存空间。</li></ul><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth - First - Search"></a>Depth - First - Search</h3><p>深度优先搜索会尽可能的深入，总是从最近发现的结点v的出发边进行探索，直到该结点所有出发边都被发现为止。一旦所有出发边都被发现，则回溯到v的前驱结点u，搜索该结点的所有出发边。此过程一直重复，知道所有可到达结点都被到达。如果图中仍有未发现结点，随机挑选另一source vertex进行探索，直到图中没有任何未发现结点。深度优先算法将生成<strong>深度优先森林</strong>。<br>初始结点是白色，被发现后变为灰色，邻接链表被扫描完成变为黑色。此方法保证每个结点只会在深度优先树中出现一次。<br>深度优先的特殊属性：<strong>时间戳（Time Stamp）</strong>v.d 记录结点第一次发现的时间（变灰的时间），v.f记录结点扫描完成的时间（变黑的时间），对于每一个结点我们有：v.f &gt; v.d</p><pre class=" language-pse"><code class="language-pse">DFS(G)for each vertex u ∈ G.V    u.color = White    u.pi = Niltime = 0for each vertex v ∈ G.V    if v.color = White        DFS-VISIT(G, v)DFS-VISIT(G, v)time = time + 1v.d = timev.color = Grayfor each u ∈ G.adj(v)    if u.color = White        u.pi = v        GFS-VISIT(G, u)v.color = Blacktime = time + 1v.f = time</code></pre><p>O(V + E)<br>深度优先的性质（properties）</p><ul><li>图结构：其生成的前驱子图G‘形成一个深度森林（深度优先树的结构与DFS-VISIT的调用结构完全相似，只有v在链表中被发现的适合，u才成为v的前驱（在u为灰色时间段里发现））</li><li>发现时间和完成时间具有括号化结构（parenthesis structure），左括号是发现时间，右括号是结束时间。well-formed expression</li><li>Parenthesis Theorem: <ul><li>[u.d, u.f] and [v.d, v.f] are entirely disjoint, and neither u nor v is a descendant of the other</li><li>[u.d, u.f] is contained entirely within the [v.d, v.f], u is a descendant of v</li><li>[v.d, v.f] is contained entirely within the [u.d, u.f], v is a descendant of u</li></ul></li><li>White - Path Theorem: vertex u 是 vertex v的后代，当且仅当v被发现的时候，有一条从v到u都是白色结点的路径</li></ul><p><strong>Topological Sort</strong></p><p>G中所有结点的线性次序，如果G包含边（u, v），则结点u在拓扑排序中处于结点v的前面（必须无环），因为u有一条边指向v，则u的结束时间一定比v晚，u的次序也一定比v前</p><pre class=" language-pseudocode"><code class="language-pseudocode">TOPOLOGICAL-SORT(G)call DFS(G) to compute finishing time v.f for each vas each vertex is finished, insert it onto the front of a linked listreturn the linked list</code></pre><p>O(V + E), 因为DFS需要此时间完成。插入linkedlist时间是O(1*V)<br><strong>Correctness</strong>：</p><ul><li>一个有向图（directed graph）是无环(acyclic graph)的当且仅当对其进行深度搜索不产生后向边</li><li>拓扑排序生成的是有向无环图的拓扑排序 - 所以有向无环图一定可以生成一个现行次序</li></ul><p><strong>Strong Connected Components</strong></p><p>DFS can decompose a directed graph into its strongly connected components. (By two DFS) SCC will be start states for many graph algorithms. <strong>Strong Connected Components (SCC)</strong> of a directed graph G is a maximal set of vertices C ⊆ V such that for every pair of vertices u and v in C, we have both u -&gt; v and v -&gt; u (u and v are reachable from each other).<br>G and the transpose of G share the same SCC. 强连通分量可以收缩成一个结点（用一个结点替换整个连通分量），这样的浓缩分量图G’是无环的。</p><p>To find SCC:<br>Use the transpose of G. G’ = (V, E’), where E’ contains the edges of G with their directions reversed. Time to create G’: O(V + E).</p><pre class=" language-pseudocode"><code class="language-pseudocode">SCC(G)call DFS(G) to compute finishing times u.f for each vertex ucompute G^Tcall DFS(G^T), but in the main loop of DFS, consider the verticesin order of decreasing u:f (as computed in line 1) 'Visit the G^T in the topological sort order'output the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component</code></pre><p>Propoerty:</p><ul><li><strong>Component Graph GSCC</strong> 将SCC的所有结点收缩到一起，构建出GSCC分量图</li><li>如果C和C’是有向图G的两个不同SCC，假设C有u和v，C‘有u’和v‘，如果G包含一条从u到u’的路径，按么G不可能包含另一条从v到v‘的路径（因为u和v，u‘和v’是互通的）</li><li>因为按照Topological sort order进行第二次DFS，因此我们可以推广时间的概念到SCC上。对于每一个SCC，定义d是最早发现的时间，即min(u.d)，f是最晚完成的时间，即max(u.f)。C和C‘是G的两个SCC，如果存在一条边(u,v)从C到C‘，则f(C) &gt; f(C’). 如果(u,v）存在于transpose G中，我们有f(C) &lt; f(C’) (路径是从C’到C的)</li></ul><h3 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth - First - Search"></a>Breadth - First - Search</h3><p>输入：G(V,E) and s</p><ul><li><p>以s为根结点，找寻所有可以从s到达的结点</p></li><li><p>计算s与其可到达节点的距离</p></li><li>输出广度优先树</li><li>广度优先树在未探索距离s为k距离的结点之前，一定不会探索（k+1）距离的结点。</li><li>广度：沿着已发现结点和未发现结点的边界向外探索（广）</li><li>Q管理的是所有灰色结点。灰色和黑色都是已经发现的结点，唯一的不同是，灰色代表白色和黑色的边界。</li><li>O(V+E)</li></ul><p>最短路径与BFS</p><p><strong>LeetCode Practical Experience</strong> </p><p>相较于Recursive solution，依靠Queue实现Iterative BFS能够节省大量的空间</p><p>N-ary Tree 的实现</p><pre class=" language-java"><code class="language-java">Public <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> val<span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>Node<span class="token operator">></span> children<span class="token punctuation">;</span><span class="token punctuation">}</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//get a unchangeable value</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Implement some operations for each node here</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>Node c <span class="token operator">:</span> node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>      q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//add node's children into queue</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//Implement some operations for each level here</span><span class="token punctuation">}</span></code></pre><p>从左到右与从右到左添加children：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//For binary tree </span><span class="token comment" spellcheck="true">//from left to right: </span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//from right to left:</span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>一些注意事项：</p><ul><li>分清楚<code>Node</code>和<code>TreeNode</code></li><li>善用Integer.MIN_VALUE和Integer.MAX_VALUE（对于负值，0会输出错误答案）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic OCmal</title>
      <link href="/2019/04/12/ocamlbasics/"/>
      <url>/2019/04/12/ocamlbasics/</url>
      
        <content type="html"><![CDATA[<h1 id="Basic-OCaml-Notes"><a href="#Basic-OCaml-Notes" class="headerlink" title="Basic OCaml Notes"></a>Basic OCaml Notes</h1><p>Compilation</p><p><code>xxx.ml</code> -&gt; <code>ocamlbuild xxx.native</code> -&gt; <code>./xxx.native</code></p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><strong>Calling functions</strong></p><p>No brackets and no comma between the arguments</p><p>（ “hello”, 3 ）is type of （’a * ‘ b）</p><p><strong>Define functions</strong></p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> average a b <span class="token operator">=</span>     <span class="token punctuation">(</span>a<span class="token operator">+.</span> b<span class="token punctuation">)</span> <span class="token operator">/.</span> <span class="token number">2.0</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(*val average: float -> float -> float = &lt;fun>*)</span></code></pre><ol><li>OCaml is a strongly <em>statically typed</em> languageå</li><li>OCaml uses <em>type inference</em> to work out the types, so you don’t have to.</li><li>OCaml doesn’t do any implicit casting. If you want a float, you have to write <code>2.0</code>because <code>2</code> is an integer. <strong>No automatic conversion</strong></li><li>As a side-effect of type inference in OCaml, functions (including operators) can’t have overloaded definitions. OCaml defines <code>+</code> as the <em>integer</em> addition function. To add floats, use <code>+.</code> (note the trailing period). Similarly, use <code>-.</code>, <code>*.</code>, <code>/.</code> for other float operations</li><li>OCaml doesn’t have a <code>return</code> keyword — the last expression in a function becomes the result of the function automatically.</li></ol><p><strong>Recursive Functions</strong></p><p> <code>let rect</code> - please explicitly say</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> range a b <span class="token operator">=</span>     <span class="token keyword">if</span> a <span class="token operator">></span> b <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">else</span> a <span class="token punctuation">:</span><span class="token punctuation">:</span> range <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> b<span class="token comment" spellcheck="true">(*val range: int -> int -> int list = fun*)</span></code></pre><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Int    31-bit signed int - 32 processors / 63-bit signed int - 64 processors</p><p>​        use 1 bit to automatically manage the memory use (garbage collection)</p><p>​        no unsigned interger type - using <code>nativeint</code></p><p>Float    IEEE double-precison (same as C)</p><p>Bool    true or false</p><p>Char    8-bit char (dont support Unicode or UTF-8) <strong>Serious flaw</strong></p><p>Unit    written as ( ) (same as void in C)</p><p><strong>Never</strong> implicit casts - <code>1+2.5</code> is a type error - <code>+</code> operator requires two ints as arguments. </p><p><code>(float_of_int i) +. f</code> - shorter alias: <code>float i +. f</code></p><p>Implicit vs. explicit casting? which is better?</p><ol><li>Type reference is such a wondeful time-saving feature</li><li>errors caused by implicit casts are hard to find</li><li>Some casts are expensive operations (i.e. int <-> float)</-></li></ol><h3 id="Types-of-Functions"><a href="#Types-of-Functions" class="headerlink" title="Types of Functions"></a>Types of Functions</h3><p>Because of type inference you will rarely if ever need to explicitly write down the type of functions.</p><p><strong>currying</strong>: <code>f: arg1 -&gt; arg2 -&gt; ... -&gt; argn -&gt; returnType</code></p><p>If return nothing (void): <code>output_char: out_channel -&gt; char -&gt; unit</code></p><p><strong>polymorphic functions</strong> take anything as an argument</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> give<span class="token punctuation">_</span>me<span class="token punctuation">_</span>a<span class="token punctuation">_</span>three x <span class="token operator">=</span> <span class="token number">3</span><span class="token comment" spellcheck="true">(*give_me_a_three: 'a -> int*)</span></code></pre><p><code>&#39;a</code> means <strong>any type</strong></p><p><strong>Type Inference</strong></p><p>Dont need to <strong>declare</strong> the types of functions and variables.</p><p>OCaml figures them out &amp;&amp; checks all types match up (even across different files!) </p><h3 id="Structure-of-OCaml"><a href="#Structure-of-OCaml" class="headerlink" title="Structure of OCaml"></a>Structure of OCaml</h3><p><strong>Local “Variables”</strong></p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> average a b <span class="token operator">=</span>     <span class="token keyword">let</span> sum <span class="token operator">=</span> a <span class="token operator">+.</span> b <span class="token keyword">in</span>         sum <span class="token operator">/.</span> <span class="token number">2.0</span><span class="token comment" spellcheck="true">(*val average: float -> float -> float = &lt;fun>*)</span></code></pre><p><code>let name = expression in</code> define a named local expression, and <code>name</code> can then be used later on in the function instead of <code>expression</code>, till a <code>;;</code></p><p>This <code>sum</code> is just a shorthand name for the expression <code>a +.b</code>, you can’t assign it later or change its value in any way. </p><p><strong>Global “Variables”</strong></p><p>Define at the top level - still a shorthand name for things</p><p><strong>Let-bindings</strong></p><p>Reference: a real variable. (It is better to create a reference and <strong>name</strong> it)</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> my<span class="token punctuation">_</span>ref <span class="token operator">=</span> ref <span class="token number">0</span><span class="token comment" spellcheck="true">(*val my_ref: int ref = {contents = 0}*)</span>my<span class="token punctuation">_</span>ref <span class="token operator">:=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(* unit = ()*)</span><span class="token operator">!</span>my<span class="token punctuation">_</span>ref<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(*int = 100*)</span></code></pre><p><code>:=</code> is used to assign, <code>!</code> dereferences </p><p><strong>Nested Functions</strong></p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> read<span class="token punctuation">_</span>whole<span class="token punctuation">_</span>channel chan <span class="token operator">=</span>    <span class="token keyword">let</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span>create <span class="token number">4096</span> <span class="token keyword">in</span>    <span class="token keyword">let</span> <span class="token keyword">rec</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>      <span class="token keyword">let</span> newline <span class="token operator">=</span> input<span class="token punctuation">_</span>line chan <span class="token keyword">in</span>      Buffer<span class="token punctuation">.</span>add<span class="token punctuation">_</span>string buf newline<span class="token punctuation">;</span>      Buffer<span class="token punctuation">.</span>add<span class="token punctuation">_</span>char buf <span class="token string">'\n'</span><span class="token punctuation">;</span>      loop <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">in</span>    <span class="token keyword">try</span>      loop <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">with</span>      End<span class="token punctuation">_</span>of<span class="token punctuation">_</span>file <span class="token operator">-></span> Buffer<span class="token punctuation">.</span>contents buf<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">val</span> read<span class="token punctuation">_</span>whole<span class="token punctuation">_</span>channel <span class="token punctuation">:</span> in<span class="token punctuation">_</span>channel <span class="token operator">-></span> string <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token keyword">fun</span><span class="token operator">></span></code></pre><p><code>let name arguments = function-definition in</code> </p><p><strong>Match</strong></p><p><code>match foo with ...</code></p><p>The following code is perfectly legal and all do the same thing</p><pre class=" language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> f x b y <span class="token operator">=</span> <span class="token keyword">if</span> b <span class="token keyword">then</span> x<span class="token operator">+</span>y <span class="token keyword">else</span> x<span class="token operator">+</span><span class="token number">0</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">if</span> b <span class="token keyword">then</span> y <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">match</span> b <span class="token keyword">with</span> <span class="token boolean">true</span> <span class="token operator">-></span> y <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">-></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">let</span> g z <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token boolean">true</span> <span class="token operator">-></span> z <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">-></span> <span class="token number">0</span> <span class="token keyword">in</span> g y b<span class="token punctuation">)</span><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">fun</span> x <span class="token operator">-></span> <span class="token keyword">fun</span> b <span class="token operator">-></span> <span class="token keyword">fun</span> y <span class="token operator">-></span> <span class="token keyword">if</span> b <span class="token keyword">then</span> x<span class="token operator">+</span>y <span class="token keyword">else</span> x<span class="token operator">+</span><span class="token number">0</span><span class="token keyword">let</span> f x b y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">_</span> <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">3</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> b <span class="token keyword">then</span> y <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">(* val f : int -> bool -> int -> int = &lt;fun> *)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CodingBetter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCmal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
